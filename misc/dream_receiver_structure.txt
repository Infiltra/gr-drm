This file shows the program flow and the usage of flags in the Dream receiver implementation.

In switch statements, DRM is assumed as ReceiverMode.

CDRMReceiver DRMReceiver
DRMReceiver.Start()
	bRunThread=TRUE
	CDRMReceiver::Run()
		CParameter & ReceiverParam = *pReceiverParam;
		bEnoughData=TRUE
		bFrameToSend=FALSE
		if bRestartFlag
			bRestartFlag=FALSE
			CDRMReceiver::SetInStartMode()
				// Load start parameters, e. g. default values for RM, protection level, mapping etc
				FreqSyncAcq.StartAcquisition()
					bAquisition = TRUE
				TimeSync.StartAcquisition()
					bTimingAcqu = TRUE
       				bRobModAcqu = TRUE
       				bAcqWasActive = TRUE
				ChannelEstimation.GetTimeSyncTrack()->StopTracking()
					bTiSyncTracking = FALSE
				ChannelEstimation.StartSaRaOffAcq();
					bSamRaOffsAcqu = TRUE
        		ChannelEstimation.GetTimeWiener()->StopTracking();
        			bTracking = FALSE
        		SyncUsingPil.StartAcquisition();
        			bAquisition = TRUE
        			bBadFrameSync = TRUE
        			bInitFrameSync = TRUE
        			bFrameSyncWasOK = FALSE
        		SyncUsingPil.StopTrackPil()
        			bTrackPil = FALSE
        		ReceiverParam.eAcquiState = AS_NO_SIGNAL
        		eReceiverState = RS_ACQUISITION
        		Reset GUI lights to not present (gray)
		ReceiveData.ReadData(ReceiverParam, RecDataBuf)
		SplitForIQRecord.ProcessData(ReceiverParam, RecDataBuf, DemodDataBuf, IQRecordDataBuf)
		DemodulateDRM(bEnoughData)
			InputResample.ProcessData(ReceiverParam, DemodDataBuf, InpResBuf)
			FreqSyncAcq.ProcessData(ReceiverParam, InpResBuf, FreqSyncAcqBuf)
				// Frequency offset estimation using frequency pilot correlation (FFT-based)
			TimeSync.ProcessData(ReceiverParam, FreqSyncAcqBuf, TimeSyncBuf)
				// 1. Frequency offset tracking estimation and Robustness mode detection method based on guard-interval
	   			// correlation.
				ReceiverParam.ReceiveStatus.TSync.SetStatus(RX_OK)
			OFDMDemodulation.ProcessData(ReceiverParam, TimeSyncBuf, OFDMDemodBuf)
			SyncUsingPil.ProcessData(ReceiverParam, OFDMDemodBuf, SyncUsingPilBuf)
				// Frame sync using time pilot correlation
				ReceiverParam.ReceiveStatus.FSync.SetStatus(RX_OK)
			ChannelEstimation.ProcessData(ReceiverParam, SyncUsingPilBuf, ChanEstBuf)
			OFDMCellDemapping.ProcessData(ReceiverParam, ChanEstBuf,MSCCarDemapBuf,FACCarDemapBuf, SDCCarDemapBuf)
		DecodeDRM(bEnoughData, bFrameToSend)
			FACMLCDecoder.ProcessData(ReceiverParam, FACCarDemapBuf, FACDecBuf)
			SDCMLCDecoder.ProcessData(ReceiverParam, SDCCarDemapBuf, SDCDecBuf)
			SymbDeinterleaver.ProcessData(ReceiverParam, MSCCarDemapBuf, DeintlBuf)
			MSCMLCDecoder.ProcessData(ReceiverParam, DeintlBuf, MSCMLCDecBuf)
			MSCDemultiplexer.ProcessData(ReceiverParam, MSCMLCDecBuf, MSCDecBuf)
		SplitFAC.ProcessData(ReceiverParam, FACDecBuf, FACUseBuf, FACSendBuf)
		if (SDCDecBuf.GetFillLevel() == ReceiverParam.iNumSDCBitsPerSFrame)
			SplitSDC.ProcessData(ReceiverParam, SDCDecBuf, SDCUseBuf, SDCSendBuf)
		SplitMSC[i].ProcessData(ReceiverParam, MSCDecBuf[i], MSCUseBuf[i], MSCSendBuf[i])
		while (bEnoughData && ReceiverParam.bRunThread)
			bEnoughData = FALSE
			WriteIQFile.WriteData(ReceiverParam, IQRecordDataBuf)
			UtilizeDRM(bEnoughData)
				UtilizeFACData.WriteData(ReceiverParam, FACUseBuf)
					DetectAcquiFAC() // If FAC CRC fails 10 times, receiver is reset.
				UtilizeSDCData.WriteData(ReceiverParam, SDCUseBuf)
				DataDecoder.WriteData(ReceiverParam, MSCUseBuf[iDataStreamID])
				AudioSourceDecoder.ProcessData(ReceiverParam,MSCUseBuf[iAudioStreamID],AudSoDecBuf))
					
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
